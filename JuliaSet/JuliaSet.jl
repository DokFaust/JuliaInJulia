
#area of the complex plane to investigate
x1, x2, y1, y2 = -1.8, 1.8, -1.8, 1.8
c = -0.62772 -.42193im

##TODO timefn() takes another function as argument and returns
##the time intercurred between the call

#function timefn(fun)
#  t1 = time()
#  result = fun(*args, **kwargs)
#  t2 = time()
#  println
#end

# function show_greyscale(output_raw, width, height, maxiter)
#   ##Convert list to array, show using ++IMAGE-LIBRARY++
#   #scal of gray should be [0...255]
#
#   maxiter = float(max(output_raw))
#   println(maxiter)
#   scale_factor = float(maxiter)
#
#   scaled = [int( o / scale_factor * 255) for o in output_raw]
#
#   #TODO transform scaled into an unsigned array
#   #or anything else that can be displayed with ++IMAGE-LIBRARY++
#
#   #TODO display with ++IMAGE-LIBRARY++
#

# function show_false_greyscale(output_raw, width, height, maxiter)
#   ##Convert list to array, show using ++IMAGE-LIBRARY++
#   #convert input to IMAGE-LIBRARY compatible input
#
#   #sanity check our 1D array and desired 2D form
#   @assert width * height == length(output_raw)
#
#   #rescale output_raw to be in inclusive range [0...255]
#   max_value = float(max(output_raw))
#   output_raw_limited = [(int(float(o) / max_value * 255) for o in output_raw)]
#
#   #NOTTODO #create a slightly fancy colour map that shows colour changes with
#   #increased contrast
#   output_rgb =((o + (256 * o) + (256 ** 2) * o) * 16 for o in output_raw_limited)
#   #thanks to somebody on github <3
#
#   #array of unsigned ints
#   output_rgb = Array{UInt64}(output_rgb)
#
#   #TODO#display with IMAGE-LIBRARY
#   #TODO create a matrix-like image (width,height)
#   #TODO using like PIL.frombytes()
#   #TODO show image
# end

function calculate_z_serial(maxiter, z)
###Calcule output list using JULIASET updating rule
#TODO Later implementation
output = zeros(length(z))

  for i in xrange(z):
    n = 0
    zs =

    return output
  end

end

function calc_pure_julia(draw_output, desired_width, maxiter)
  ###Create a list of complex coordinates (zs) and complex parameters (cs)
  ###Build a Julia set and display

  x_step = (float(x2-x1) / float(desired_width))
  y_step = (float(y2-y1) / float(desired_width))

  x = []
  y = []

  ycoord = y2
  while ycoord > y1
    push!(y,ycoord) #ycoord goes decreasing
    ycoord += y_step #rember that y_step is negative
  end

  xcoord = x1
  while xcoord < x2
    push!(x,xcoord)
    xcoord += x_step
  end

  #set width and height as generated by pixel counts
  #rather than pre-rounding desired width and height
  width = length(x)
  height = length(y)

  #build a list of coordinates and the initial condition of each cell
  #Now the initial condition is constant for the julia set, so we can
  #as it is

  zs = []
  for ycoord in y, xcoord in x
    push!(zs, xcoord + ycoord * im)
  end

  println("Length of x : ", $length(x))
  println("Total elements:", $length(zs))

  start_time = time_ns()
  output = calculate_z_serial(maxiter, zs, cs)
  end_time = time_ns() #TEST time_ns should return the time in nanoseconds
  secs = (end_time - start_time) / 10^9
  println("Computations took", $secs, "seconds")

   if draw_output
  #   show_greyscale(output, width,height,maxiter)
  #   show_false_greyscale(output, width, height,maxiter)
   end

end

calc_pure_julia(draw_output=False, desired_width = 1000, maxiter=300)
